---
# https://github.com/longhorn/charts/tree/v1.8.x/charts/longhorn#prerequisites
- name: Prepare nodes for Longhorn
  tags: prepare
  hosts: k8s_all
  become: true
  vars_files: &vars_files1
    - vars/basics.yml
    - vars/kubernetes.yml
    - vars/storage.yml
  pre_tasks:
    - name: Is iscsi_tcp module loaded?
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html
      ansible.builtin.shell:
        cmd: grep -q iscsi_tcp <(lsmod)
        executable: /bin/bash
      register: iscsi_tcp
      changed_when: false
      failed_when: false
  tasks:
    - name: Load iscsi_tcp kernel module
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html
      ansible.builtin.command: modprobe iscsi_tcp
      when: iscsi_tcp.rc
      changed_when: true

    - name: Enable and start iSCSI daemon
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/systemd_service_module.html
      ansible.builtin.systemd_service:
        name: iscsid
        state: started
        enabled: true
        daemon_reload: true

    # multipathd is known to have a breakage that affects Longhorn:
    # https://longhorn.io/kb/troubleshooting-volume-with-multipath/
    - name: Disable the multipath daemon
      ansible.builtin.systemd_service:
        name: multipathd
        state: stopped
        enabled: false

    - name: Run Longhorn environment check
      become: false
      vars:
        script_url: https://raw.githubusercontent.com/longhorn/longhorn/v{{
          longhorn_chart_version }}/scripts/environment_check.sh
      ansible.builtin.shell: |
        # run Bash and source /etc/profile.d
        # scripts so that kubectl is in PATH
        exec /bin/bash -l <<'EOF'
        set -o pipefail

        # sed command strips colored output
        curl -s {{ script_url }} | bash | \
          sed -r 's/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g'
        EOF
      timeout: 120
      register: env_check
      # run once in each cluster
      when: >-
        inventory_hostname in [
          k3s_control_plane_host,
          rke_control_plane_host
        ]
      changed_when: false

    - name: Show environment check results
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html
      ansible.builtin.debug:
        msg: "{{ env_check.stdout }}"
      when: env_check.stdout is defined
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/search_test.html
      failed_when: env_check.stdout is search('\\[ERROR\\]')
  any_errors_fatal: true

# create LVM logical volume /data for
# Kubernetes local persistent volumes
- name: Create LV for Longhorn PVs
  tags: lvs
  hosts: cluster
  # https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_strategies.html#rolling-update-batch-size
  # serial: 1
  become: true
  vars_files:
    - vars/storage.yml
  vars:
    lv_dev: /dev/{{ data_lv.vg }}/{{ data_lv.lv }}
  pre_tasks:
    - name: Check if LV already exists
      ansible.builtin.command: lvdisplay -c {{ lv_dev }}
      register: lv_exists
      changed_when: false
      failed_when: false
  tasks:
    - name: Create {{ data_lv.size }} logical volume
      # https://docs.ansible.com/ansible/latest/collections/community/general/lvol_module.html
      community.general.lvol:
        lv: "{{ data_lv.lv }}"
        vg: "{{ data_lv.vg }}"
        size: "{{ data_lv.size }}"
        state: present
        resizefs: true
      # lvdisplay returns 5 if LV not found
      when: lv_exists.rc == 5

    - name: Create {{ data_lv.fs | upper }} filesystem
      # https://docs.ansible.com/ansible/latest/collections/community/general/filesystem_module.html
      community.general.filesystem:
        fstype: "{{ data_lv.fs }}"
        dev: "{{ lv_dev }}"
        resizefs: true

    - name: Mount LV on {{ data_lv.mount }}
      # https://docs.ansible.com/ansible/latest/collections/ansible/posix/mount_module.html
      ansible.posix.mount:
        src: "{{ lv_dev }}"
        path: "{{ data_lv.mount }}"
        fstype: "{{ data_lv.fs }}"
        state: mounted
  any_errors_fatal: true

- name: Install Longhorn components
  tags: longhorn
  # install just on RKE cluster for now
  hosts: "{{ rke_control_plane_host }}"
  gather_facts: false
  vars_files: *vars_files1
  vars:
    # required kubernetes>=24.2 package only in user virtualenv
    ansible_python_interpreter: "{{ venv_python_interpreter }}"
  tasks:
    # https://longhorn.io/docs/1.8.1/deploy/install/install-with-helm/
    # https://github.com/longhorn/charts/tree/v1.8.x/charts/longhorn
    - name: Install Longhorn Helm chart
      # https://docs.ansible.com/ansible/latest/collections/kubernetes/core/helm_module.html
      kubernetes.core.helm:
        kubeconfig: "{{ rke_kubeconfig }}"
        chart_repo_url: https://charts.longhorn.io
        chart_ref: longhorn
        chart_version: "{{ longhorn_chart_version }}"
        release_name: longhorn
        # cannot use any other namespace!
        release_namespace: longhorn-system
        create_namespace: true
        release_values: "{{ longhorn_chart_values }}"
        atomic: true
      timeout: 300
  any_errors_fatal: true

# https://computingforgeeks.com/configure-nfs-as-kubernetes-persistent-volume-storage/
- name: Install NFS dynamic provisioner
  tags: nfs
  hosts:
    - "{{ k3s_control_plane_host }}"
    - "{{ rke_control_plane_host }}"
  gather_facts: false
  vars_files: *vars_files1
  vars:
    # required kubernetes>=24.2 package only in user virtualenv
    ansible_python_interpreter: "{{ venv_python_interpreter }}"
    # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/ternary_filter.html
    cluster: "{{ (inventory_hostname == k3s_control_plane_host) | ternary('k3s','rke') }}"
  tasks:
    - name: Install NFS provisioner Helm chart
      vars:
        provisioners: "{{ nfs_provisioners | selectattr('cluster', '==', cluster) }}"
        mount_options: "{{ nfs_mount_opts | split(',') }}"
        storage_class: |
          {# https://docs.ansible.com/ansible/latest/collections/ansible/builtin/combine_filter.html #}
          {% set storage_class = item.storageClass | ansible.builtin.combine({
               'name': item.storageClass.name | default('nfs-'~ item.name)
          }) %}
          {{ storage_class }}
      kubernetes.core.helm:
        kubeconfig: "{{ vars[cluster ~'_kubeconfig'] }}"
        chart_repo_url: https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner
        chart_ref: nfs-subdir-external-provisioner
        release_name: "{{ item.name }}"
        release_namespace: nfs-provisioner
        create_namespace: true
        # https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/tree/master/charts/nfs-subdir-external-provisioner/values.yaml
        release_values:
          nfs:
            server: "{{ item.server }}"
            path: "{{ item.path }}"
            mountOptions: "{{ mount_options }}"
          storageClass: "{{ storage_class }}"
        atomic: true
      loop: "{{ provisioners }}"
      loop_control:
        label: "{{ item.name }}"
  any_errors_fatal: true

# https://operator.min.io/
# https://resources.min.io/
- name: Install MinIO storage for QNAP
  tags: minio
  hosts: "{{ rke_control_plane_host }}"
  gather_facts: false
  vars_files: &vars_files2
    - vars/basics.yml
    - vars/kubernetes.yml
    - vars/storage.yml
    - vars/minio.yml
  vars:
    # required kubernetes>=24.2 package only in user virtualenv
    ansible_python_interpreter: "{{ venv_python_interpreter }}"
    kubeconfig: "{{ rke_kubeconfig }}"
  tasks:
    - name: Create MinIO ingress secret
      vars:
        cert_desc: MinIO ingress
        cert_file: minio
        secret_name: "{{ minio_secrets['ingress'] }}"
        secret_ns: "{{ minio_tenant_namespace }}"
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/include_tasks_module.html
      ansible.builtin.include_tasks: tasks/k8s/secrets/tls.pki.yml
      # sets pem_chain fact

    - name: Set ca_certs fact from pem_chain
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/set_fact_module.html
      ansible.builtin.set_fact:
        # pem_chain fact set by tasks/k8s/secrets/tls.pki.yml
        # above contains both intermediate and root CA certs
        ca_certs: "{{ pem_chain[1:] | join('\n') }}"

    - name: Create MinIO CA certs secret
      vars:
        secret_name: "{{ item.name }}"
        secret_data:
          # must use name "public.crt"
          public.crt: "{{ ca_certs }}"
        secret_ns: "{{ item.namespace }}"
        create_ns: "{{ item.namespace != minio_tenant_namespace }}"
      ansible.builtin.include_tasks: tasks/k8s/secrets/generic.yml
      loop:
        - name: "{{ minio_secrets['operator-ca'] }}"
          namespace: "{{ minio_operator_namespace }}"
        - name: "{{ minio_secrets['tenant-ca'] }}"
          namespace: "{{ minio_tenant_namespace }}"
      loop_control:
        label: "{{ item.name }}"

    # NOTE: these secrets do not appear to be used
    # by references in TenantSpec.users because no
    # users get created--we do it explicitly using
    # mc in the next play
    # https://min.io/docs/minio/kubernetes/upstream/reference/operator-crd.html#tenantspec
    - name: Create MinIO user credentials
      vars:
        secret_name: minio-creds-{{ item.key }}
        secret_data:
          CONSOLE_ACCESS_KEY: "{{ item.key }}"
          CONSOLE_SECRET_KEY: "{{ item.value.secret_key }}"
        secret_ns: "{{ minio_tenant_namespace }}"
        create_ns: false
      ansible.builtin.include_tasks: tasks/k8s/secrets/generic.yml
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/dict2items_filter.html
      loop: "{{ minio_users | ansible.builtin.dict2items }}"
      loop_control:
        label: "{{ item.key }}"

    # https://min.io/docs/minio/kubernetes/upstream/operations/install-deploy-manage/deploy-operator-helm.html
    - name: Install MinIO Operator Helm chart
      kubernetes.core.helm:
        kubeconfig: "{{ kubeconfig }}"
        chart_repo_url: https://operator.min.io
        chart_ref: operator
        chart_version: "{{ minio_operator_chart_version }}"
        release_name: operator
        release_namespace: "{{ minio_operator_namespace }}"
        release_values: "{{ minio_operator_chart_values }}"
        atomic: true
      timeout: 300

    # https://min.io/docs/minio/kubernetes/upstream/operations/install-deploy-manage/deploy-minio-tenant.html
    # https://min.io/docs/minio/kubernetes/upstream/operations/install-deploy-manage/deploy-minio-tenant-helm.html
    - name: Install MinIO Tenant Helm chart
      kubernetes.core.helm:
        kubeconfig: "{{ kubeconfig }}"
        chart_repo_url: https://operator.min.io
        chart_ref: tenant
        chart_version: "{{ minio_tenant_chart_version }}"
        release_name: tenant
        release_namespace: "{{ minio_tenant_namespace }}"
        release_values: "{{ minio_tenant_chart_values }}"
        atomic: true
      timeout: 300

    - name: Wait until MinIO tenant is ready
      # https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.html
      ansible.builtin.uri:
        url: https://{{ minio_s3api_fqdn }}/
        status_code: [403]
      # https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_loops.html#retrying-a-task-until-a-condition-is-met
      register: tenant_check
      until: tenant_check.status == 403
      retries: 24
      delay: 5
  any_errors_fatal: true

- name: Create MinIO buckets/users/groups
  tags: buckets
  hosts: cluster
  gather_facts: false
  vars_files: *vars_files2
  tasks:
    # https://min.io/docs/minio/linux/reference/minio-mc-admin.html#installation
    - name: Install MinIO client
      become: true
      ansible.builtin.shell: |
        cd /usr/local/bin
        set -o pipefail

        ARCH=$(uname -m | sed -e 's/aarch64/arm64/' \
                              -e  's/x86_64/amd64/')
        BIN="https://dl.min.io/client/mc/release/linux-$ARCH/mc"
        v=$(curl -fsSL "$BIN.minisig" | grep RELEASE)
        VER=$(v="${v##*.}"; echo "${v%T*}")

        # check if latest version already installed
        command -v mc &> /dev/null && {
          v=$(mc --version | grep RELEASE)
          ver=$(v="${v#*.}"; echo "${v%%T*}")
          [ "$ver" == "$VER" ] && exit 9 # no change
        }
        curl -fsSLO $BIN
        chmod +x mc
      args:
        executable: /bin/bash
      register: install_mc
      changed_when: install_mc.rc == 0
      failed_when: >-
        install_mc.rc != 0 and
        install_mc.rc != 9

    - name: Configure MinIO client
      vars:
        root_user: "{{ minio_tenant_chart_values.tenant.configSecret }}"
      ansible.builtin.shell: |
        # set MC_CONFIG_DIR
        . ~/.bash_aliases

        [  -d "$MC_CONFIG_DIR" ] && exit 9 # no change
        mkdir "$MC_CONFIG_DIR"

        mc config host add local \
          https://{{ minio_s3api_fqdn }} \
               {{ root_user.accessKey }} \
              '{{ root_user.secretKey }}'
      args:
        executable: /bin/bash
      register: config_mc
      changed_when: config_mc.rc == 0
      failed_when: >-
        config_mc.rc != 0 and
        config_mc.rc != 9

    - name: Create buckets/users/groups
      # mc is installed on all hosts
      # but run commands on just one
      when: inventory_hostname == rke_control_plane_host
      ansible.builtin.shell: |
        # set MC_CONFIG_DIR
        . ~/.bash_aliases
        set -o pipefail

        # get list of existing buckets:
        # https://min.io/docs/minio/linux/reference/minio-mc/mc-ls.html
        buckets="$(mc ls local --json | jq -r .key)"
        {% for name, bucket in minio_buckets.items() %}

        grep -q "^{{ name }}/$" <<< "$buckets" || {
          # https://min.io/docs/minio/linux/reference/minio-mc/mc-mb.html
          mc mb {{ bucket.options | join(' ') if
                   bucket.options is defined and
                   bucket.options }} \
            local/{{ name }}
          rc=0
        }
        {% endfor %}

        # get list of existing policies:
        # https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-policy-list.html
        policies="$(mc admin policy ls local --json | jq -r .policy)"
        {% for name, policy in minio_policies.items() %}

        grep -q "^{{ name }}$" <<< "$policies" || {
          {% set doc = {
               'Version':  '2012-10-17',
               'Statement': policy.Statement
             } %}
          # https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-policy-create.html
          # only takes path to JSON file
          mc admin policy create local \
              {{ name }} <(cat <<'EOF'
        {{ doc | to_json }}
        EOF
          )
          rc=0
        }
        {% endfor %}

        # get list of existing users:
        # https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-user-list.html
        users="$(mc admin user ls local --json | jq -r .accessKey)"
        {% for access_key, user in minio_users.items() %}

        grep -q "^{{ access_key }}$" <<< "$users" || {
          # https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-user-add.html
          mc admin user add local {{ access_key }} '{{ user.secret_key }}'
          rc=0

          {% if user.policies is defined and user.policies %}
          # https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-policy-attach.html
          mc admin policy attach local       \
             {{ user.policies | join(' ') }} \
              --user {{ access_key }}
          {% endif %}
        }
        {% endfor %}

        # get list of existing groups:
        # https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-group.html#mc.admin.group.ls
        groups="$(mc admin group ls local --json | jq -r .groups[])"
        {% for name, group in minio_groups.items() %}

        grep -q "^{{ name }}$" <<< "$groups" || {
          # cannot create a group with no members, so
          # must create after users have been created:
          # https://min.io/docs/minio/linux/reference/minio-mc-admin/mc-admin-group.html#mc.admin.group.add
          mc admin group add local {{ name }} \
              {{ group.members | join(' ') }}
          rc=0

          {% if group.policies is defined and group.policies %}
          mc admin policy attach local        \
             {{ group.policies | join(' ') }} \
              --group {{ name }}
          {% endif %}
        }
        {% endfor %}
        exit ${rc-9}
      args:
        executable: /bin/bash
      register: mc_create
      changed_when: mc_create.rc == 0
      failed_when: >-
        mc_create.rc != 0 and
        mc_create.rc != 9
  any_errors_fatal: true
